import type {DocumentData, DocumentReference} from 'firebase/firestore';
import {addDoc, collection, deleteDoc, doc, getDoc, onSnapshot, setDoc, updateDoc} from 'firebase/firestore';
import {firestore} from '/@/services/firebaseService';
import type {Ref} from 'vue';
import {ref} from 'vue';
import {IClient} from '/@/utils/interfaces/clientInterface';
import {v4 as uuidv4} from 'uuid';
import { IClientInfo, IHost } from '/@/utils/interfaces/hostInterface';
import { diff_match_patch } from 'diff-match-patch';


const dmpInstance = new diff_match_patch();

//config webRTC - stun & turn servers
const config = {
  iceServers: [
    {
      urls: [
        'stun:stun.l.google.com:19302',
        'stun:stun1.l.google.com:19302',
        'stun:stun2.l.google.com:19302',
        'stun:stun3.l.google.com:19302',
        'stun:stun4.l.google.com:19302',
      ],
    },
  ],
  // iceCandidatePoolSize: 10,
};

// 'stun:stun.services.mozilla.com:3478',

export class PeerRTC {
  public peerConnection = new RTCPeerConnection(config);
  protected codeChannel: RTCDataChannel | null = null;
  public connectionState: Ref<string> = ref('');
  public isConnected: Ref<boolean> = ref(false);
  roomId: string = '';


  constructor() {
    this.registerPeerConnectionListeners();
  }

  //I think this will only work for a peer, the ice candidates remoteName will change depending from one peer to another ... (
  protected async collectIceCandidates(
    roomRef: DocumentReference<DocumentData, DocumentData>,
    localName: string,
    remoteName: string,
  ) {
    const localCandidateCollection = collection(roomRef, localName);

    // If local peer finds an ice candidate(a possible route), send it signaling server and store it in its collection.
    this.peerConnection.addEventListener('icecandidate', event => {
      if (event.candidate === null) return;
      const body = event.candidate!.toJSON();
      addDoc(localCandidateCollection, body);
    });

    // If a remote peer updates its ice collection (possible routes), then add it to my list of ice candidates.
    const remoteCandidateCollection = collection(roomRef, remoteName);
    onSnapshot(remoteCandidateCollection, snapshot => {
      snapshot.docChanges().forEach(change => {
        if (change.type === 'added') {
          const candidate = new RTCIceCandidate(change.doc.data());
          this.peerConnection.addIceCandidate(candidate);
        }
      });
    });
  }

  private registerPeerConnectionListeners() {
    this.peerConnection.onconnectionstatechange = _ => {
      this.connectionState.value = this.peerConnection.connectionState;
      if (this.peerConnection.connectionState === 'connected') this.isConnected.value = true;
      if (
        this.peerConnection.connectionState === 'disconnected' ||
        this.peerConnection.connectionState === 'closed'
      )
        this.isConnected.value = false;
      //https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/connectionstatechange_event
    };
  }
}

export class HostPeerRTC extends PeerRTC implements IHost {
  //I will organize this later, but every host has
  name: string = 'Host';
  isHosting: boolean = false;
  clientList: Ref<Map<string, IClientInfo>> = ref(new Map()); //NO NEED TO HAVE TWO DIFFERNT MAPS, also no need to have uuid as the clientInfo, but its f
  clientsContent: Ref<Map<string, string>> = ref(new Map());

  constructor() {
    super();
    this.createCodeChannel(this.peerConnection);
  }

  /**
   * Tries to establish a WebRTC connection.
   * Its creates a Room/Offer and sends it to the signaling server.
   * Listens for answers from other Peers.
   * Listens for data channels from other Peers.
   * It also starts sending and storing local and remote ice candidates.
   * @returns a promise<string> containing the roomID or error
   */
  public async hostRoom(): Promise<string> {
    //generate offer and store in signaling server
    
    try {
      if (this.isHosting) return this.roomId;
      const offer = await this.peerConnection.createOffer();
      const roomWithOffer = {
        offer: {
          type: offer.type,
          sdp: offer.sdp,
        },
      };
      const roomRef = await addDoc(collection(firestore, 'rooms'), roomWithOffer);
      this.roomId = roomRef.id;
      console.log('---- Creating room', this.roomId);

      this.collectIceCandidates(roomRef, 'offerCandidates', 'answerCandidates');
      await this.peerConnection.setLocalDescription(offer);

      //Listen for an answer that will be generated by another Peer, and set it to be the remote dession description.
      onSnapshot(roomRef, async (snapshot: any) => {
        const data = snapshot.data();
        if (!this.peerConnection.currentRemoteDescription && data.answer) {
          console.log('---- Received answer', data);
          this.clientList.value.set(data.info.uuid, data.info);
          this.listenToCodeChannel(data.info.uuid);
          const answer = new RTCSessionDescription(data.answer);
          await this.peerConnection.setRemoteDescription(answer);
        }
      });

      this.isHosting = true;
      return this.roomId;
    } catch (err: any) {
      console.log('---- Error hosting webRTC', err)
      throw err;
    }
  }

  public destroy(): void {
    this.codeChannel?.close();
    this.peerConnection.close();
    deleteDoc(doc(firestore, 'rooms', this.roomId));
    //unsubscribe from the onSnapshot listener
    //unsubscribe from the onIceCandidate listener
    //unsubscribe from the peerConnection listeners generally ...
    //make sure that the object is cleared from memory somehow ...
  }

  private createCodeChannel(peerConnection: RTCPeerConnection): void {
    this.codeChannel = peerConnection.createDataChannel('codeChannel');
  }

  private listenToCodeChannel(clientUUID: string): void {
    if (!this.codeChannel) return;
    this.codeChannel!.onmessage = (event: any) => {
      console.log('---- receiving data:', event.data);
      console.log(event);
      let patches = dmpInstance.patch_fromText(event.data);
      this.clientsContent.value.set(clientUUID, dmpInstance.patch_apply(patches, this.clientsContent.value.get(clientUUID) ?? '')[0]);
    };

    this.codeChannel!.onopen = () => {
      console.log('Code channel opened.');
    };

    this.codeChannel!.onclose = () => {
      console.log('Code channel closed.');
    };
  }
}

export class ClientPeerRTC extends PeerRTC implements IClient {
  
  uuid: string = '';
  name: string = 'Client';
  content: Ref<string> = ref('');

  constructor() {
    super();
    this.setupCodeChannel();
  }

  /**
   * Tries to establish a WebRTC connection with the host.
   * It gets the offer from the signaling server and creates an answer.
   * It sends the answer to the signaling server.
   * It starts updating remote and local ice candidates list.
   * It creates a dataChannel.
   * @param roomId string
   * @returns promise<void>
   */
  public async joinRoom(roomId: string): Promise<void> {
    try {

      this.roomId = roomId;
      const roomRef = doc(firestore, 'rooms', roomId);
      const roomSnapshot = await getDoc(roomRef);
  
      if (!roomSnapshot.exists) return;
  
      this.collectIceCandidates(roomRef, 'answerCandidates', 'offerCandidates');
  
      //creates an answer based on the offer and sets it to be the local sdp and sends it to the server
      const offer = roomSnapshot!.data()!.offer;
      await this.peerConnection.setRemoteDescription(offer);
      const answer = await this.peerConnection.createAnswer();
      await this.peerConnection.setLocalDescription(answer);
  
      const roomWithAnswer = {
        info: {
          name: this.name,
          uuid: this.uuid,
        },
        answer: {
          type: answer.type,
          sdp: answer.sdp,
        },
      };
      await updateDoc(roomRef, roomWithAnswer);
    } catch (err: any) {
      throw err;
    }
  }
  
  public setInfo(clientName: string) {
    this.name = clientName;
    if (!this.uuid) this.uuid = uuidv4();
  }

  
  /**
   * Sends text to the peer using codeChannel.
   * @param text string
   */
  public sendCode(content: string): void {
    console.log('--- sending data:', content);
    if (this.codeChannel && this.codeChannel.readyState === 'open') this.codeChannel.send(content);
  }

  //TODO: need to fix this to manage multiple data channels.
  private setupCodeChannel() {
    this.peerConnection.addEventListener('datachannel', event => {
      console.log('----- on data channel', event);
      // event.channel.label //I could use label based on the uuid.
      //so in the signaling step (using the signaling server) I can send the uuid of the client to the host, which then can be used to create a new unique data channel for that client.
      this.codeChannel = event.channel;
      //TODO: either manual connection of channels., or use an id or naem of the channel to manage multiple peers.

      // Set up event listeners and handle data channel events
      this.codeChannel.onmessage = (event: any) => {
        console.log(event.data, 'received');
      };

      this.codeChannel.onopen = () => {
        console.log('Code channel opened.');
      };

      this.codeChannel.onclose = () => {
        console.log('Code channel closed.');
      };
    });
  }

  public destroy(): void { //Could this be moved to the parent class?
    this.codeChannel?.close();
    this.peerConnection.close();
    //unsubscribe from the onSnapshot listener
    //unsubscribe from the onIceCandidate listener
    //unsubscribe from the peerConnection listeners generally ...
    //make sure that the object is cleared from memory somehow ... 
  }

}
